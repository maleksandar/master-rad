% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage[latinica]{matfmaster}
\usepackage{graphicx}
\usepackage{pangrami}

% Paket koji obezbeđuje ispravni prikaz ćiriličkih italik slova kada
% se koristi pdflatex. Zakomentarisati ako na sistemu koji koristite ovaj
% paket nije dostupan ili ako ne radi ispravno.
\usepackage{cmsrb}
\usepackage[font={small}]{caption}
% Ostali paketi koji se koriste u dokumentu
\usepackage{listings} % listing programskog koda
\usepackage{color} %use color
\usepackage{enumitem}
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{codegray}{gray}{0.9}
\newcommand{\code}[1]{\colorbox{codegray}{\texttt{\scalebox{0.9}{#1}}}}%

\newcounter{shellRef}[chapter]

\newcommand{\shellcmd}[2]{\\\\\texttt{\footnotesize\$ #1 \null\hfill (\refstepcounter{shellRef}{\theshellRef})\label{#2} }\\\\}
\renewcommand{\theshellRef}{\thechapter.\number\numexpr\value{shellRef}\relax}

\let\origthelstnumber\thelstnumber
\makeatletter
\newcommand*\Suppressnumber{%
  \lst@AddToHook{OnNewLine}{%
    \let\thelstnumber\relax%
     \advance\c@lstnumber-\@ne\relax%
    }%
}

\newcommand*\Reactivatenumber[1]{%
  \setcounter{lstnumber}{\numexpr#1-1\relax}
  \lst@AddToHook{OnNewLine}{%
   \let\thelstnumber\origthelstnumber%
   \refstepcounter{lstnumber}
  }%
}

\makeatother
% %Customize a bit the look
% \lstset{ %
% backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
% basicstyle=\footnotesize, % the size of the fonts that are used for the code
% breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
% breaklines=true, % sets automatic line breaking
% captionpos=b, % sets the caption-position to bottom
% commentstyle=\color{mygreen}, % comment style
% deletekeywords={...}, % if you want to delete keywords from the given language
% escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
% extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
% frame=false, % adds a frame around the code
% keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
% keywordstyle=\color{blue}, % keyword style
% % language=Octave, % the language of the code
% morekeywords={*,...}, % if you want to add more keywords to the set
% numbers=left, % where to put the line-numbers; possible values are (none, left, right)
% numbersep=5pt, % how far the line-numbers are from the code
% numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
% rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
% showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
% showstringspaces=false, % underline spaces within strings only
% showtabs=false, % show tabs within strings adding particular underscores
% stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
% stringstyle=\color{mymauve}, % string literal style
% tabsize=2, % sets default tabsize to 2 spaces
% title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
% }
%END of listing package%
 

%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, const, class, interface, this, get, string, number, extends, export, new, true, false, catch, function, return, null, catch, let, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={export, boolean, throw, implements, extends, public, protected, import, from, private},
ndkeywordstyle=\color{red}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{mygreen}\ttfamily,
moredelim=[s][\color{black}]{\$\{}{\}}, % same as morestring in this case
morestring=[d]{'},
morestring=[d]{`},
morestring=[d]{"},
}

\lstdefinelanguage{html}{
keywords={body, div, div,span, i, script, h1, const},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{mygreen}\ttfamily,
morestring=[b]',
morestring=[b]"
}


\lstdefinelanguage{shell}{
keywords={\$, \> },
keywordstyle=\color{red}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{mygreen}\ttfamily,
morestring=[b]',
morestring=[b]`,
morestring=[b]"
}


\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
backgroundcolor=\color{white},
showstringspaces=false,
showspaces=false,
numbers=none,
numberstyle=\footnotesize,
escapeinside=||,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b,
}

\lstset{
language=shell,
extendedchars=true,
basicstyle=\footnotesize\ttfamily,
backgroundcolor=\color{lightgray},
frame=single,
showstringspaces=false,
showspaces=false,
numbers=none,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

\lstdefinestyle{htmlStyle} {language=html,backgroundcolor=\color{white},frame=single}
\lstdefinestyle{jsStyle} {language=JavaScript, escapeinside=||, backgroundcolor=\color{white},frame=single, numbers=left, numberstyle=\tiny, }
\lstdefinestyle{shellStyle} {language=shell,backgroundcolor=\color{lightgray},frame=single}

\renewcommand\lstlistingname{Prikaz koda}
\setlist[enumerate]{itemsep=0mm}
% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Aleksandar Milosavljević}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Razvoj "Pure" okruženja za razvoj veb interfejsa}
% Godina u kojoj je teza predana komisiji
\godina{2021}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{dr Saša \textsc{Malkov}, vanredni profesor\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{dr Aleksandar \textsc{Kartelj}, docent\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{dr Ivan \textsc{Čukić}, docent\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{15. јануар 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%
Rezime placeholder
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{veb, internet, interfejs, html, css, javaskript, razvojno okruženje}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Svima osim LaTex-u}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Uvod}
% Poboljšanje infrstrukture Internet mreže, to jest, povećanjem brzine i stabilnosti 
% internet komunikacije,
% naša interakcija sa računarima danas izgleda značajno drugačije nego pre 20 godina. 
% Umesto stonih računara sa velikim kućištima i glasnim rashladnim sistemima,
% današnji najrasprostranjeniji računari nam staju u džep. Koristimo ih kako bi 
% komunicirali sa bližnjima i bili u toku sa svetskim dešavanjima.

% Iako današnji mini računar koji gotovo svi nosimo u džepu ima više procesorske moći 
% nego računar koji je korišćen tokom Appolo misije(ref), 
% danas te lične računare ne koristimo za teška izračunavanja i komplikovane procedure. 
% Koristimo ih najčešće kao terminale kako bismo pristupili internet resursima,
% to jest, podacima koji se nalaze na velikim centralizovanim računarskim sistemima. 
% Veb interfejs je tako postao glavni način naše interakcije sa računarom i internetom.

% Posledica toga je značajna promena fokusa u svetu razvoja aplikativnog softvera.
% Ukoliko pogledamo rezultat upitnika kompanije "Stack Overflow" 
% (ref)({\url{https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages-professional-developers}})
% o najkorišćenijim programerskim alatima, videćemo da prva dva mesta na listi
% zauzimaju upravo veb tehnologije (Na prvom mestu je JavaScript sa 69.7\%, dok je na 
% drugom HTML/CSS sa 62.4\%).

% Kako potreba za novim softverom daleko prevazilazi mogućnost softverskih inženjera 
% da taj softver isporuče, biblioteke i okruženja koja pomažu pri razvoju softvera 
% postali su veoma važan deo inženjerskog alata.
% U domenu razvoja veb aplikacija, na tržištu se izdvajaju tri razvojna okruženja. 
% Ova tri razvojna okruženja najviše se međusobno razlikuju po pristupu u promeni 
% stanja aplikacije i razumevanju
% toga šta je centralni deo dizajna (u funkcionalnom smislu) jedne veb aplikacije.

% Kada posmatramo ova popularna razvojna okruženja, uočavamo dva bitno različita 
% pristupa u arhitekturi:
% \begin{enumerate}
%   \item {\emph{Model-Pogled-Upravljač}} šablon u kom aplikacija predstavlja skup
%    povezanih komponenti organizovanih u hijerarhisku strukturu, kojima je 
%    pridruženo stanje i ponašanje
%   \item Flux šablon u kom se aplikacija posmatra kao mašina stanja čija je 
%   vizuelna reprezentacija samo rezultat trenutnog stanja.
% \end{enumerate}

% Prvi pristup je prisutan u okruženju Angular, drugi je dominantan u biblioteci 
% React, dok Vue.js zastupa dizajn koji predstavlja kompromis izmеđu ova dva pristupa.

% Kroz ovaj rad ispratićemo razvoj jednog modernog razvojnog okruženja za izradu 
% SPA veb aplikacija.


% ------------------------------------------------------------------------------
\chapter{Arhitektura SPA}
Poboljšanjem infrastrukture Interneta i napredovanjem tehnologije i mogućnosti
ličnih računara
i mobilnih uređaja, prezentaciona logika korisničkih aplikacija se postepeno
selila sa centralizovanih
serverskih računara na klijentske uređaje. SPA (eng. \emph{Single Page Application}) arhitektura je dovela ovaj princip
do krajnjih granica
prebacivanjem celokupne logike prikaza na klijentsku stranu \cite{SPA}. U ovoj arhitekturi klijent
pri prvom zahtevu
ka serveru preuzima celokupnu logiku prikaza aplikacije i obrađuje je u
pretraživaču, dok
svi naredni pozivi služe prostoj razmeni podataka. Ovo je značajno uticalo
na samu metodologiju razvoja softvera.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{slike/SPA_Diagram (3).png}
  \caption{Dijagram sekvence SPA arhitekture.}
  \label{fig:SPA}
\end{figure}\\
Ovaj pristup omogućio je nezavistan razvoj timovima zaduženim za
serversku logiku od timova zaduženih za prezentacionu logiku i vizuelni dizajn.
Jedina tačka spajanja ova dva tima postao je dizajn interfejsa
između klijentske i serverske aplikacije. Rešenje ovog problema inženjeri su našli
u REST (eng. \emph{Representational State Transfer}) arhitekturalnom šablonu \cite{REST}.
Odvajanjem razvoja klijentskih i serverskih aplikacija, postalo je moguće razviti
složene korisničke aplikacije. Povećavanjem složenosti razvoja ovih aplikacija,
razvila se potreba za razvojnim šablonima i razvojnim okruženjima koja omogućavaju
programerima da lakše organizuju svoj kod i da lakše njime upravljaju.
Prvi šabloni koji su se koristili preuzeti su iz perioda višestraničnih aplikacija.
Primer jednog takvog šablona je \emph{Model-Pogled-Upravljač} (eng. \emph{Model-View-Controller})\cite{MVC}. 

\section{Šablon Model-Pogled-Upravljač}

Šablon \emph{Model-Pogled-Upravljač} nastao je pre pojave SPA arhitekture.
Koristio se za velike sajtove i aplikacije, ali na takav način da su sve komponente pisane
kao serverski kod. Ideja šablona \emph{Model-Pogled-Upravljač} je da omogući razdvajanje odgovornosti
između logike podataka, aplikativne logike i vizuelne reprezentacije programa.
Ovaj šablon ima istu primenu i u SPA aplikacijama, sa tom razlikom što se sve odvija na klijentu.
Umesto apstrakcije nad bazom podataka, \emph{model} predstavlja apstrakciju nad podacima učitanim
u aplikaciju. \emph{Upravljač} (ili kontroler) je zadužen za aplikativnu logiku i za prihvatanje
instrukcija poslatih sa nivoa \emph{pogleda}. Sloj \emph{pogleda} služi za opis vizuelne
reprezentacije aplikacije i ne sadrži nikakvu aplikativnu logiku. Najpoznatiji predstavnik okruženja
koja koriste ovaj šablon je \emph{Angular} \cite{Angular}.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{slike/MVC_pattern (1).png}
  \caption{Arhitektura šablona Model-Pogled-Upravljač}
  \label{fig:MVC}
\end{figure}
\section{Šablon Flux}
Šablon \emph{Flux} je nastao u kompaniji \emph{Facebook}, iz potrebe inžinjera da otklone probleme sa 
deljenjem stanja između različitih komponenti i čestim stanjem utrkivanja (eng. \emph{race condition} \cite{raceCondition}).
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{slike/FLUX_pattern.png}
  \caption{Arhitektura Šablona Flux}
  \label{fig:flux}
\end{figure}
\\
Osnovna ideja ovog šablona je da podaci teku u jednom smeru, tako da se uvek može jednostavno
utvrditi redosled akcija i na taj način sprečiti stanja utrkivanja.
\emph{Pogled}, kao i kod šablona \emph{Model-Pogled-Upravljač}, služi za opis vizualne reprezentacije programa.
\emph{Pogled} utiče na tok podataka tako što pri korisničkom događaju odabira \emph{akciju} koju će da emituje
ka \emph{skupljaču} (eng. \emph{reducer}). \emph{Skupljač} je čista funkcija \cite{functionalProgramming}, koja kao argumente
prihvata akciju i trenutno stanje skladišta i vraća novo stanje skladišta.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.7\textwidth]{slike/Reducer.png}
  \caption{Skupljač}
  \label{fig:reducer}
\end{figure}
\\
Važno je naglasiti da šablon \emph{Flux} za razliku od šablona \emph{Model-Pogled-Upravljač} ne insistira
na podeli slojeva po fajl strukturi na takav način da dva sloja ne mogu biti deo istog fajla.
Razdvajanje odgovornosti se ovde posmatra u domenu toka podataka i koji sloj \emph{kada} može
upravljati i pristupati podacima. Biblioteka \emph{React} nastala je u kompaniji \emph{Facebook} kao predstavnik ovog šablona \cite{React}.
% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------
\chapter{Problemi sa popularnim okruženjima}\label{chap:problemi}
Iako su moderna razvojna okruženja poput okruženja \emph{Angular} i biblioteke \emph{React} omogućila
programerima da napišu veoma kompleksne korisničke aplikacije, to ne znači da ova okruženja
nemaju svoje mane i zamke. Ovde ćemo pomenuti neke od njih.
\section{Problemi sa okruženjem Angular}
Okruženje \emph{Angular} popularno je među programerima koji razvijaju softver za korporativne korisnike.
Razvojni timovi koji rade na razvoju ovakvog softvera često broje preko 20 inžinjera i testera.
Šablon \emph{Model-Pogled-Upravljač} koji prestavlja osnovni arhitekturalni dizajn okruženja Angular,
značajno olakšava rad velikom broju ljudi na istoj kodnoj bazi.
\subsection{Upravljanje stanjem} \label{subsec:upravljanje-stanjem}

Problem sa okruženjem \emph{Angular} nastaje kada među različitim komponentama delimo stanje. Stanje utrke vremenom počinje da
se javlja sve češće kao problem, a "pametna krpljenja" počinju da zauzimaju sve veći deo kodne baze.

Problem sa deljenjem stanja, pored stanja utrkivanja, je i taj što aplikacija postaje previše kompleksna
za razumevanje čak i za iskusnije inžinjere i problemi u kodu se vremenom sve bolje sakrivaju,
čekajući na krajnje korisnike.


\subsection{Logika u pogledu} \label{subsec:logika-u-pogledu}
Pogledajmo jedan primer koda sa sajta \url{https://angular.io/}:
\begin{lstlisting}[style=htmlStyle, caption={Isečak Angular koda},label=angular:code]
<div *ngFor="let item of items">{{item.name}}</div>
\end{lstlisting}
Kod prikazan u isečku \ref{angular:code} predstavlja primer za izlistavanje stavki (\code{item}) iz niza \code{items}.
Drugim rečima, ovo nije HTML\footnote{Hyper-Text-Markup-Language} element, već jedna instrukcija napisana \emph{Angular} jezikom za opisivanje
pogleda, koja će u vremenu izvršavanja biti zamenjena sa pravim HTML elementom.
Ovo je jednostavan primer, ali nije teško zamisliti situaciju u kojoj programska logika postaje previše kompleksna
da bi se o njoj rezonovalo u slučaju potrage za greškom. Da stvar bude gora, ovu logiku nije moguće (jednostavno) debagovati\footnote{\emph{Debug} - eng. Traženje i uklanjanje grešaka},
jer logika ispisana ovde prolazi kroz više faza prevođenja i uglavnom je izvršava
optimizovani i minifikovani kod samog okruženja.
\section{Problemi sa bibliotekom React}
Okruženje \emph{React} razvijeno je od strane \emph{Facebook} inžinjera sa ciljem da stvore okruženje
dizajnirano tako da šablon \emph{Flux} bude lak za implementaciju pri razvoju aplikacija.
Ovaj model okruženja omogućio je u velikoj meri izbegavanje problema stanja utrkivanja, ali
su neki drugi problemi ipak ostali deo dizajna.
\subsection{Razdvajanje odgovornosti} \label{subsec:razdvajanje-odgovornosti}
U prikazima \ref{file:react.jsx} i \ref{file:react.js} vidimo primer preuzet sa zvanične veb stranice \emph{React} biblioteke.
U pitanju su dva različita načina definisanja \emph{React} komponente. U primeru \ref{file:react.jsx}
je prikazan način koji koristi \emph{JSX} sintaksu. \emph{JSX} je skraćenica za \emph{JavaScript-XML}, što može da se uoči i iz prikazanog primera.
Ideja je da se komponenta može u potpunosti opisati u jednom fajlu sa ekstenzijom \code{.jsx} (ili \code{.tsx} ako koristite \emph{TypeScript} \cite{TypeScript}).
Umesto posebnog fajla koji bi koristio HTML sintaksu (ili sintaksu nalik HTML sintaksi, kao što je to slučaj u okruženju \emph{Angular}),
u biblioteci \emph{React}, struktura komponente može se opisati na istom mestu gde i ponašanje komponente.
Ovo često omogućava lakše rezonovanje povezanosti vizualne strukture komponente i njenog ponašanja i predstavlja
pristup razdvajanja odgovornosti na nivou komponenenata, a ne na nivou tehnologije. 
Ovaj mehanizam se u u pozadini ostvaruje tako što React transpajlira ovaj kod na čist \emph{JavaScript} (prikaz \ref{file:react.js}).
Korisnik može svoje komponente pisati i na način prikazan u primeru \ref{file:react.js}, ali je
primer \ref{file:react.jsx} očigledno lakši za čitanje i rezumevanje strukture.

Iako je ovo veoma zgodan mehanizam, uvodi neke neželjene posledice. Naime, jako je teško utvrditi šta je ispravan,
a šta neispravan \emph{JSX} kod i gde su tačno granice gde počinje HTML, a zavšava se \emph{JavaScript}. To možemo uočiti i na
primeru \ref{file:react.jsx}. Element \code{<h1>} u ovom primeru ima postavljenu vrednost atributa \code{className} na nisku \code{"greeting"}.
Ovaj atribut zapravo se pri prevođenju na HTML element, tumači kao \code{class}. Razlog zašto ne koristimo reč \code{class}
u \emph{JSX} kodu je taj što je \code{class} rezervisana reč u \emph{JavaScript}-u.

Ovo je samo jedan dobro poznat primer koji zbunjuje nove korisnike, ali ovakvih, bolje sakrivenih primera ima dosta.
Ovaj sistem opisa vizuelne strukture podleže gotovo istim problemima kao i \emph{Angular}-ov jezik za opis strukture (eng. \emph{Templating language}),
u smislu da ga je gotovo nemoguće debagovati.
\\
\\
\noindent\begin{minipage}[b]{.46\textwidth}
\begin{lstlisting}[style=htmlStyle, numbers=left, numberstyle=\tiny, caption={Fajl \code{ToDoApp.ts}},label=file:react.jsx]
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[b]{.46\textwidth}
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{ToDoApp.ts}},label=file:react.js]
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
\end{lstlisting}
\end{minipage}
\subsection{Okruženje ili biblioteka}
Iako \emph{React} nije razvojno okruženje u punom smislu te reči, već biblioteka koja se bavi isključivo opisom sloja pogleda,
mnogi inženjeri ga koriste u sklopu ekosistema kao deo razvojnog okruženja.
Sve ostale funkcionalnosti koje su neophodne za kompletno razvojno okruženje deo su drugih biblioteka (\emph{ReactDOM, Redux, Mobx...}).
Ovo dovodi do velike heterogenosti u pristupu pisanja koda i zbog toga nema jedinstvenog pristupa rešavanju većini problema
koji se javljaju pri razvoju aplikacija. Ovo je upravo razlog zbog kojeg je \emph{Angular} u velikim korporacijskim okruženjima i timovima
i dalje dominantan izbor.
% ------------------------------------------------------------------------------
\chapter{Okruženje Pure}
Kako bismo se upoznali detaljnije sa novim okruženjem, krenućemo od jednostavnog
primera, "Zdravo svete" (eng. \emph{"Hello world"}) aplikacije.
\section{Preduslovi}
Kako bismo mogli da pokrenemo \emph{Pure} aplikaciju neophodno je da radno okruženje
\emph{Node.js}\cite{Node} bude instalirano na računaru. Preporučena verzija u vreme pisanja ovog rada je \texttt{14.17.5}.
(LTS\footnote{\emph{Long Term Support} - eng. Dugoročna tehnička podrška}).
Pored okruženja Node.js, neophodno je da na računaru bude instaliran i \emph{git},
Pored ovih neophodnih alata, preporučuje se i korišćenje modernog programa za obradu teksta
sa podrškom za jezik \emph{TypeScript}\cite{TypeScript}. Autor preporučuje alat otvorenog koda, razvijen od strane
Microsoft inžinjera: \emph{Visual Studio Code}\cite{vsc}.

Okruženje \emph{Pure} može se preuzeti preko \emph{npm}
\footnote{ \emph{Node Package Manager} - eng. Upravljač Paketa za Node} sistema \cite{npm}.
To možemo uraditi na dva načina:
\begin{enumerate}
  \item Instaliranjem paketa \code{pure-framework} u već postojeći \emph{npm} modul.
  (konzolna komanda: \ref{cmd:npm-install})
  \item Pokretanjem skripte za pravljenje \code{hello-world} projekta, bez prethodnog
  instaliranja \emph{npm} paketa. (konzolna komanda: \ref{cmd:npx})
\end{enumerate}
\section{Zdravo svete!}
Ukoliko već imamo postojeći \emph{npm} modul na kojem radimo, možemo u okviru njega
instalirati \code{pure-framework} komdanom:
\shellcmd{npm install pure-framework}{cmd:npm-install}
Ovde ćemo prikazati jednostavniji pristup u kojem krećemo sa praznim
direktorijumom, u kom ćemo pomoću \emph{npx} skripte napraviti početnu "Zdravo svete"
aplikaciju. Potrebno je da se u terminalu pozicioniramo u prazan direktorijum i da
odatle pokrenemo komandu:
\shellcmd{npx pure-framework hello-world}{cmd:npx}
Izvršavanje ove komande napraviće novi direktorijum sa nazivom \code{hello-world} i u njega
klonirati repozitorijum\footnote{Repozitorijum: \url{https://github.com/maleksandar/pure-framework-hello-world-app}}
sa minimalnom \emph{Pure} aplikacijom. 
Ukoliko je skripta izvršena bez grešaka, direktorijum \code{hello-world} bi trebalo
da sadrži fajlove prikazane na slici \ref{fig:hello-world-direktorijum}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.5\textwidth]{slike/hello-world-direktorijum.PNG}
  \caption{Графикон}
  \label{fig:hello-world-direktorijum}
\end{figure}
Kako bismo pokrenuli našu aplikaciju, potrebno je da se pozicioniramo u 
novonapravljeni direktorijum i instaliramo neophodne \emph{npm} pakete,
izvršavanjem komande:
\shellcmd{cd hello-world \&\& npm install}{cmd:npm-install-hello-world}
Nakon što se ova komanda uspešno izvrši, možemo da pokrenemo našu aplikaciju
komandom:
\shellcmd{npm run start}{cmd:npm-start}
Ukoliko pokretanje ove komande nije izbacilo grešku, konzola bi trebalo da nas 
obavesti da je server za razvoj pokrenut i da možemo da mu pristupimo na simboličkoj
adresi \url{http://localhost:1234} (konzolni odgovor \ref{konzola:npmstart})\\
\renewcommand\lstlistingname{Konzolni odgovor}
\begin{lstlisting}[style=shellStyle, caption={Konzolna poruka nakon pokretanja aplikacije}, label=konzola:npmstart]
> pure-framework-hello-world-app@1.0.0 start
> parcel index.html

Server running at http://localhost:1234
Built in 27ms
\end{lstlisting}
\renewcommand\lstlistingname{Prikaz koda}

Ukoliko u pretraživaču otvorimo stranicu \url{http://localhost:1234},
trebalo bi da vidimo stranicu koja izgleda kao na slici \ref{fig:hello-world} 

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{slike/hello-world-strana.PNG}
  \caption{"Zdravo svete" aplikacija, pokrenuta na lokalnom serveru.}
  \label{fig:hello-world}
\end{figure}
\pagebreak

\subsection{Struktura aplikacije}
% Pogledajmo sada sadržaj fajlova koje smo napravili u koraku \ref{cmd:npx}.
% Primetićemo da fajlovi \code{index.html} i \code{index.ts} gotovo da ne sadrže
% nikakvu programsku logiku ili opis strukture DOM\footnote{ Document Object Model} drveta.
% U narednim poglavljima upoznaćemo se detaljnije sa svrhom ovih fajlova, ali ćemo
% te detalje za sada preskočiti.

Fajl koji sadrži centralnu logiku naše aplikacije je \code{src/App.ts} (Prikaz \ref{file:app.ts})
\begin{lstlisting}[style=jsStyle, caption={Sadržaj fajla \code{App.ts}},label=file:app.ts]
import { Component, componentFactory } from "pure-framework/core";
import { div, span } from "pure-framework/html";
import { AppModel } from "./model";

class AppComponent extends Component<AppModel> {
  template() {
    return div({ class: 'app-root'}, [
      span(`Hello ${this.state.name}! Welcome! `),
      span(`The answer to the utimate question of life, the universe and everything is: ${this.state.answer}`)
    ]);
  }
}
export const app = componentFactory(AppComponent);
\end{lstlisting}

Ukoliko pogledamo aplikaciju u pretraživaču (slika \ref{fig:hello-world})
videćemo da struktura HTML elemenata odgovara strukturi koju vraća funkcija \code{template()}.

Recimo da želimo da dodelimo ponašanje našoj aplikaciji, tako da svaki put kada
kliknemo na <div> element povećamo broj iz pozdravne za jedan, a ime promenimo na "Ford".
To možemo da uradimo tako što ćemo izmeniti funkciju \code{template()} na sledeći način:

\begin{lstlisting}[style=jsStyle, firstnumber=6, caption={Fajl \code{App.ts} nakon dodate funkcionalnosti},label=file:app.ts:2]
template() {
  return div({ class: 'app-root'}, [
      span(`Hello ${this.state.name}! Welcome! `),
      span(`The answer to the utimate question of life, the universe and everything is: ${this.state.answer}`)
  ]).on('click', () => {
    store.updateState({
      answer: this.state.answer + 1,
      name: 'Ford'
    })
  });
}
\end{lstlisting}
\pagebreak
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{slike/hello-ford.PNG}
  \caption{Hello World aplikacija, nakon dodavanja funkcionalnosti.}
  \label{fig:hello-ford}
\end{figure}

Ukoliko otvorimo ponovo našu aplikaciju u pretraživaču i kliknemo na nju dva puta,
trebalo bi da uоčimo da broj koji se prikazuje na kraju poruke više nije 42, već 44,
dok je pozdravna poruka ovog puta, umesto Arturu, namenjena Fordu (slika \ref{fig:hello-ford}).
\section{Struktura Pure aplikacija}
Nakon pravljenja prvog programa u okruženju \emph{Pure}, pogledaćemo detaljnije strukturu i
značenje fajlova jedne \emph{Pure} aplikacije oslanjajući se na primer "Zdravo svete" aplikacije.
\subsection{Mesto povezivanja}\label{subsec:mesto-povezivanja}
Prvi fajl koji se učitava i izvršava, nakon fajla \code{index.html} je \code{index.ts} (Prikaz \ref{file:index.ts}).
Zbog toga u njemu pozivamo funkciju za povezivanje (eng. \emph{bootstrap}) aplikacije.
Metoda \code{bootstrap()} prihvata tri argumenta.
\begin{enumerate}
  \item Referencu na koreni element DOM drveta aplikacije. To jest, element iz fajla \code{index.html} koji želimo da zamenimo sa \emph{Pure} aplikacijom.
  \item Konstruktorsku funkciju korene komponente napisane u okruženju \emph{Pure}.
  \item Referencu na objekat koji upravlja skladištem (eng. \emph{storage / store}).  
\end{enumerate}
Treći argument služi tome da okruženje može da osluškuje promene stanja u objektu \code{store} i tako
zna kada treba da obnovi iscrtavanje elemenata.
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{index.ts}},label=file:index.ts]
import { bootstrap } from "pure-framework/core";
import { app } from "./src/App";
import { store } from "./src/store";

bootstrap(document.getElementById('app'), app, store);
\end{lstlisting}

\subsection{Komponente}
Komponente sadrže logiku i vizuelni opis segmenta aplikacije. Svaka komponenta u okruženju Pure
mora da nasledi apstraktnu klasu \code{Component<T>}, gde generički argument \code{<T>} predstavlja tip modela podataka komponente.
Konstruktor komponente ne treba pozivati direktno, već je potrebno
napraviri posredničku funkciju (eng. \emph{proxy}) koju možemo napraviti pomoću funkcije \code{componentFactory} koja se uvozi sa putanje
\code{"pure-framework/core"}. Razlog za ovo, kao i detalji implementacije funkcije \code{componentFactory} biće pojašnjeni u kasnijim poglavljima.

Klasa \code{Component<T>} sadrži razne metode,
ali ćemo se u ovom delu fokusirati na dve: Metodu \code{template()} i metodu \code{render()}.

Metoda \code{template()} je apstraktna metoda koju mora da implementira
svaka komponenta koja nasleđuje klasu \code{Component<T>}. Ona sadrži vizuelnu strukturu komponente i po potpisu funkcije
mora da vrati objekat tipa \code{FunctionalElement}. Tip \code{FunctionalElement} je interfejs koji implementiraju sve funkcije iz
kolekcije ugrađenih funkcionalnih elemenata (\code{div()}, \code{span()}, \code{h1()}, ...). Važno je napomenuti
da i klasa \code{Component<T>} implementira interfejs \code{FunctionalElement}, što znači da povratna vrednost metode \code{template()} takođe može biti i druga komponenta.
\subsection{Funkcionalni elementi}

Sve ugrađene funkcionalne elemente, koji služe opisu ugrađenih HTML elemenata, mogu se uvesti sa putanje \code{"pure-framework/html"}.
Ugrađeni funkcionalni elementi (funkcije uvežene iz \code{"pure-framework/html"}) poštuju isti potpis.
Ove funkcije podrazumevano prihvataju dva argumenta:
\begin{enumerate}
  \item Objekat atributa. \label{enum:attr-list}
  \item Listu unutrašnjih elemenata. (Lista čvorova-dece)
\end{enumerate}
Važno je napomenuti da ukoliko se prosledi samo jedan argument, podrazumeva se da je u pitanju lista unutrašnjih elemenata,
a ne objekat atributa, jer je češći slučaj da HTML element nema definisane atribute, nego što je slučaj da nema podčvorove.
Ukoliko element sadrži samo jedan unutrašnji element, možemo i izostaviti pakovanje tog elementa u niz i pustiti da okruženje
to uradi umesto nas.
Svi ovi izuzeci dodati su u okruženje radi lakše čitljivosti i smanjenja suvišnog koda. U prikazima \ref{file:functionalElement} i \ref{file:htmlElement}
možemo videti kako se prevodi jedna
struktura funkcionalnih elemenata u HTML elemente.
\\
\\
\noindent\begin{minipage}[b]{.46\textwidth}
\begin{lstlisting}[style=jsStyle, numbers=left, numberstyle=\tiny, caption={Funkcionalni element},label=file:functionalElement]
div({ class: 'app-root'}, [
  span('First span'),
  span('Second span'),
  div({ class: 'inner-div'}, [
    span([
      span('This span is left from'),
      italic(' italic text'),
      span(', and this one is on the right of it.'),
    ])
  ])
]);
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[b]{.46\textwidth}
\begin{lstlisting}[style=htmlStyle, numbers=left, numberstyle=\tiny, caption={Rezultujući HTML},label=file:htmlElement]
<div class="app-root">
  <span>First span</span>
  <span>Second span</span>
  <div class="inner-div">
    <span>
      <span>This span is left from</span>
      <i> italic text</i>
      <span>, and this one is on the right of it.</span>
    </span>
  </div>
</div>
\end{lstlisting}
\end{minipage}

\subsection{Model i skladište podataka}
Modeli u okruženju Pure ne sadrže nikakvu logiku i pišu se pomoću interfejsa u \emph{TypeScript}-u, tako da postoje samo u fazi razvoja.
U fazi izvršavanja, ovi fajlovi nisu deo izvornog koda, zato što se uklanjaju u postupku prevođenja.
Njihova svrha je samo da nam obezbede striktne tipove pri navođenju podrazumevanih vrednosti i spreče eventualne logičke greške u fazi izvršavanja.
Model "Zdravo svete" aplikacije može se videti na prikazu \ref{file:model.ts}.
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{src/model.ts}},label=file:model.ts]
export interface AppModel {
  name: string;
  answer: number;
} 
\end{lstlisting}
Skladište koje se koristi u okviru okruženja Pure zasnovano je na mehanizmu
\emph{BehaviorSubject}-a\footnote{\emph{BehaviorSubject} - eng. Subjekt ponašanja} iz biblioteke \emph{RxJs}. 
Kako bismo napravili jednu instacu skladišta za našu aplikaciju, potrebno je da pozovemo konstruktor \code{Store<T>}
koji moramo uvezemo sa putanje \code{"pure-framework/core"}. Konstruktor \code{Store<T>} prima jedan generički argument tipa modela,
i jedan standardni argument koji predstavlja objekat podrazumevanog stanja koji odgovara po svojoj strukturi prosleđenom generičkom argumentu (Prikaz \ref{file:store.ts}).

\begin{lstlisting}[style=jsStyle, caption={Fajl \code{src/model.ts}},label=file:store.ts]
import { Store } from "pure-framework/core";
import { AppModel } from "./model";

export const store = new Store<AppModel>({
    name: 'Arthur',
    answer: 42
})
\end{lstlisting}

% U kasnijim poglavljima ćemo se detaljnije upoznati sa time kako ovaj kod zapravo radi.
\section{Aplikacija "Menadžer Zadataka"}
Pogledaćemo sada malo kompleksniji primer.
U pitanju je aplikacija za upravljanje dnevnim obavezama\footnote{\emph{eng. TO-DO} lista.}.
Online verzija ove aplikacije nalazi se na stranici
\url{https://pure-framework-todo-demo.netlify.app/} (Slika \ref{fig:todo-app}).
Izvorni kod aplikacije nalazi se na adresi: 
\\\url{https://github.com/maleksandar/pure-framework-todo-app}


\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.5\textwidth]{slike/todo-app-online.PNG}
  \caption{Оnline verzija TO-DO aplikacije}
  \label{fig:todo-app}
\end{figure}
\subsection{Struktura aplikacije}

Pogledajmo sada isečak koda koji odgovara korenoj komponenti \code{ToDoApp} koja se nalazi u fajlu \code{src/ToDoApp.ts}: 
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{ToDoApp.ts}},label=file:ToDoApp.ts]
import { ... }; // Lista zavisnosti skracena zbog citljivosti |\Suppressnumber|
... |\Reactivatenumber{7}|
class ToDoApp extends Component<ToDoState> {|\Suppressnumber|
...|\Reactivatenumber{19}|
  template() {
    return div({ class: 'wrapper' }, [
      this.headerSegment(),
      this.todoSegment(),
      this.footerSegment(),
    ]);
  } |\Suppressnumber|
...|\Reactivatenumber{46}|
  private todoSegment() {
    return ul({ class: 'todoList' },[
      ...this.state.todoList.map((item) =>
        li([
          item,
          span({ class: 'icon' }, [
            italic({ class: 'fas fa-trash' }, [])
          ]).on('click', () => {
            let index = this.state.todoList.findIndex(x => x == item);
            this.state.todoList.splice(index, 1);
            store.updateState(this.state);
          })
        ]))
    ]);
  }|\Suppressnumber|
...|\Reactivatenumber{109}|
}

export const todoApp = componentFactory<ToDoApp, ToDoState>(ToDoApp);

\end{lstlisting}
% U isečku \ref{file:ToDoApp.ts} vidimo metodu \code{template()} i privatnu metodu \code{todoSegment()}.
% Metoda \code{template()} je apstraktna metoda nadklase \code{Component<ToDoState>}
% koju moramo da implementiramo za svaku korisnički definisanu komponentu.
% Ova metoda opisuje rezultujuće DOM drvo komponente u momentu iscrtavanja.
% \pagebreak
% \\Metoda \code{template()} u ovom primeru vraća rezultat poziva funkcije \code{div()},
% koja prima dva argumenta:
% \begin{enumerate}
%   \item Objekat atributa. \label{enum:attr-list}
%   \item Listu unutrašnjih elemenata. (Lista čvorova dece)
% \end{enumerate}
\pagebreak
Ukoliko pogledamo strukturu liste potomaka u metodi \code{template()} (Prikaz \ref{file:ToDoApp.ts}) videćemo da ona upravo opisuje tri vizualna segmenta aplikacije \ref{fig:todo-app}:
\begin{enumerate}
  \item Zaglavlje sa naslovom, poljem za unos novog zadatka i dugmetom za potvrdu unosa (Funkcija \code{headerSegment()}).
  \item Segment sa listom aktuelnih zadatka (Funkcija \code{todoSegment()}).
  \item Podnožje sa prikazom zbirnih informacija i dugmetom za brisanje liste aktuelnih zadataka (Funkcija \code{footerSegment()}).
\end{enumerate}

Na isečku koda \ref{file:ToDoApp.ts} prikazan je kod funkcije koja opisuje segment sa listom aktuelnih zadataka.
Funkcija \code{todoSegment()} vraća funckcionalni element \code{ul()} (Koji odgovara \code{<ul>} HTML elementu).
Na liniji 48 vidimo poziv \emph{spread (eng. raširi)} operatora nad nizom koji se dobija kao rezultat mapiranja niza
\code{this.state.todoList} u niz \code{li} elemenata. Svaki od \code{li} elemenata takođe sadrži dva deteta-čvora, od kojih jedan
predstavlja nisku koja sadrži opis zadatka i dugme za uklanjanje zadatka.

Funkcija za uklanjanje pojedinačnih zadatka opisana je kodom koji počinje na liniji 54, prikaza \ref{file:ToDoApp.ts}.
Primetimo bitan detalj na liniji 56, u kojem pozivamo metodu nad objektom \code{store} sa novim, izmenjenim stanjem.
Ovaj poziv je neophodan kako bismo korenoj komponenti signalizirali promenu stanja aplikacije, i naterali okruženje da ponovo
izvrši iscrtavanje.

Ova veza između \code{todoApp} komponente i \code{store} objekta ostvarena je pozivanjem metode \code{bootstrap()} u fajlu \code{index.ts} (Prikaz \ref{file:index.ts}).
% \begin{lstlisting}[style=jsStyle, caption={Fajl \code{ToDoApp.ts}},label=file:index.ts]
% import { bootstrap } from "pure-framework/core";
% import { todoApp } from "./src/ToDoApp";
% import { store } from "./src/store";

% bootstrap(document.getElementById('app'), todoApp, store);
% \end{lstlisting}
Pogledajmo sada šta sadrži objekat \code{store}, koji uvozimo iz fajla \code{src/store.ts} (Prikaz \ref{file:store.ts}).
% \begin{lstlisting}[style=jsStyle, caption={Fajl \code{src/store.ts}},label=file:store.ts]
% import { Store } from "pure-framework/core";
% import { ToDoState } from "./model";

% export const store = new Store<ToDoState>({
%   todoList: [
%       'Kupi mleko',
%       'Odvezi auto kod majstora',
%       'Napisi master rad',
%       'Odbrani master rad',
%   ]
% });
% \end{lstlisting}
Na osnovu prikaza \ref{file:store.ts} vidimo da je \code{store} objekat instanca klase \code{Store} koja je definisana u okviru paketa \code{pure-framework}.
Konstruktor ove klase prima generički argument (\code{ToDoState}) koji opisuje model podataka naše aplikacije (model podataka korene komponente) i inicijalizujući objekat,
koji se koristi kao podrazumevano stanje komponente ili u ovom slučaju cele aplikacije.

Model podataka aplikacije opisan je \emph{TypeScript} interfejsom koji je definisan u fajlu \code{src/model.ts} (Prikaz \ref{file:todo-model.ts})
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{src/model.ts}},label=file:todo-model.ts]
export interface ToDoState {
  todoList: string[];
}
\end{lstlisting}
\chapter{Zahtevi}
Pre upuštanja u detalje implementacije okruženja \emph{Pure}
razmotrimo zahteve koje bi jedno novo razvojno okruženje trebalo da ispuni.
\begin{enumerate}
  \item Kako bi izbeglo probleme iz poznatijih okruženja kao što su
  \textbf{logika u pogledu} (Odeljak \ref{subsec:logika-u-pogledu}) i
  \textbf{razdvajanje odgovornosti} (Odeljak \ref{subsec:razdvajanje-odgovornosti})
  okruženje \emph{Pure} ne sme da uvodi novi, niti koristi bilo kakav postojeći
  specijalizovani jezik za opisivanje HTML-a. Dodatni zahtev u pogledu
  opisa HTML strukture komponenenata je mogućnost debagovanja
  logike i strukture izgleda komponente.
  \item 
  Kako bi se izbegao problem sa deljenjem stanja (Odeljak \ref{subsec:upravljanje-stanjem}), \emph{Pure} treba da
  se oslanja na šablon \emph{Flux} i jednosmeran tok podataka.
  Stanje mora biti centralizovano, a interfejs za upravljanje stanjem
  mora biti robustan i konzistentan među komponentama.
 \item Kako bi što manje grešaka došlo do korisnika, potrebno je uočiti
 što više grešaka koje je moguće detektovati u fazi razvoja.
 \item Distribucija razvojnog okruženja \emph{Pure} mora biti dostupna kroz
 javni repozitorijum \emph{npm} paketa.
 \item Okruženje \emph{Pure} mora biti otvoreno za modifikaciju.
 \item Komponente okruženja \emph{Pure} moraju imati jednostavnu i lako čitljivu strukturu. 
\end{enumerate}
% \section{}%bez uvođenja novog jezika
% \section{}%One way data flow
% \section{}%Typescript
\chapter{Implementacija okruženja Pure}
% \section{Repozitorijumi}
U ovom poglavlju pogledaćemo detalje implementacije okruženja \emph{Pure} i pojasniti neke odluke u dizajnu okruženja.

Ime okruženja \emph{Pure}\footnote{\emph{Pure} - eng. Čisto, čist} inspirisano je 
funkcionalnom paradigmom i čistim funkcijama. Funkcionalni elementi (koji će biti opisani u ovom poglavlju),
predstavljaju uslovno rečeno čiste funkcije, koje prihvataju trenutno stanje kao argument i vraćaju
DOM-element kao rezultat. Ovo nam omogućava da implementiramo i mehanizam memoizacije (eng. \emph{Memoization}),
koji je iskorišćen kao mehanizam optimizacije.

Drugi razlog za ime \emph{Pure} dolazi iz činjenice da okruženje koristi isključivo \emph{JavaScript}
za opis strukture DOM-drveta i ponošanja, pa ime \emph{Pure} možemo shvatiti i u konteksu \emph{Pure JavaScript} iliti \emph{Čist JavaScript}.

\section{Dizajn okruženja Pure}
Okruženje Pure preuzima šablon \emph{Flux} od biblioteke \emph{React}, ali inspiraciju za konretnu implementaciju ovog šablona
preuzima od biblioteke \emph{NgRx} koja je deo \emph{Angular}-ekosistema. Od okruženja \emph{Angular}
preuzima pristup razvoju koji podrazumeva pisanje komponenti u jeziku \emph{TypeScript} umesto jezika \emph{JavaScript}.
\subsection{Zašto ne HTML?}
Iako je HTML oproban alat za opisivanje strukture dokumenta, on ima svoja ograničenja koja nije tako lako prevazići.
Programi za obradu teksta pri pisanju HTML fajla uglavnom teško mogu da zaključe kontekst povezivanja
pojedinačnih HTML-elemenata sa konkretnim funkcijama i promenljivima napisanim u \emph{JavaScript}-u i zbog toga je podrška alata,
a samim tim i iskustvo tokom pisanja HTML koda, značajno lošija nego pri pisanju \emph{JavaScript} ili \emph{TypeScript} koda.
Dodatna mana je u tome što je jako teško segmentirati HMTL kod u hijerarhijsku strukturu ili ga podeliti na više fajlova,
jer u HTML jeziku ne postoji opcija za uključivanje podkomponenti.
Korišćenjem \emph{TypeScript} funkcija umesto HTML sintakse rešavaju se ovi problemi.
Alati za upravljanje \emph{TypeScript} kodom značajno su napredniji od alata za upravljanje HTML-om.

\section{Korišćeni alati, tehnologije i biblioteke}
Za rešavanje većine problema opisanih u poglavlju \ref{chap:problemi} postoje različiti alati i biblioteke. 
Kako bi fokus okruženja \emph{Pure} trebalo da budu do sada nerešeni (ili nedovoljno adekvatno rešeni) problemi,
potrebno je odabrati i uvezati ove postojeće alate na pravi način. U ovom poglavlju ćemo opisati glavne
alate i biblioteke koje predstavljaju deo okruženja \emph{Pure}, ili su korišćene tokom razvoja okruženja.

\subsection{Typescript}
\emph{TypeScript} je strogo tipizirani programski jezik izgrađen oko jezika \emph{JavaScript}.
Prednost korišćenja strogih tipova u pisanju aplikacija leži u mogućnosti programskih alata
da veliki opseg grešaka otkriju u fazi razvoja. Primera radi, ukoliko funkcija očekuje nisku
kao tip podataka, a mi nad tim argumentom pozivamo metodu koja nije definisana na prototipu niske (REFERENCA: Prototipsko nasleđivanje),
kompajler će nam izbaciti grešku i upozoriti nas da to (verovatno) nije metoda koju smo želeli da pozovemo.

Pošto \emph{TypeScript} predstavlja suštinski samo nadskup jezika JavaScript (korišćenje tipova je opciono),
možemo jednostavno balansirati između striktnih tipova i sigurnosti sa jedne strane i čitljivosti koda sa druge,
tako da je cena uvođenja ove tehnologije u okruženje veoma niska, a dobici mogu biti značajni.
\subsection{Parcel}
\emph{Parcel} je popularan \emph{bundler}\footnote{\emph{Bundler} - eng. Upakivač, Zapakivač. Onaj koji pakuje.} za veb aplikacije.
\emph{Bundler} u razvojnim okruzenjima ima dva zaduženja:
\begin{enumerate}
  \item Pravljenje \emph{produkcionog} \emph{JavaScript} fajla. sa minifikovanim i "poruznjenim" kodom (
    REFERENCA: minification \& uglificatrion).
  \item Povezivanje koda i veb pretraživača tokom pisanja koda.
\end{enumerate} 
\emph{Produkcioni JavaScript} fajl je fajl koji sadrži celokupnu logiku aplikacije, ali je za potrebe brzog preuzimanja i
učitavanja od strane pretraživača preveden na nižu verziju EcmaScript standarda (zbog starijih verzija pretraživača), minifikovan i "poružnjen".
Ukratko, sve beline iz koda su uklonjene, a varijable preimenovane u kraća simbolička imena.

Glavna prednost \emph{bundler}-a \emph{Parcel} je u minimalnoj neophodnoj konfiguraciji.
Konkretan razlog zbog kog je \emph{Parcel} odabran kao \emph{bundler}, je taj što \emph{Parcel} automatski
prevodi \emph{TypeScript} kod na \emph{JavaScript} bez ikakve dodatne konfiguracije, pa zbog toga možemo u okviru
\code{index.html} fajla direktno da zahtevamo \emph{TypeScript} fajl (primer \ref{file:html-Typescript}).
\begin{lstlisting}[style=htmlStyle,numberstyle=\tiny, caption={Uključivanje \emph{TypeScript} fajla direktno u \code{index.html}}, label=file:html-Typescript]
<script src="index.ts" type="module"></script>
\end{lstlisting}

\subsection{RxJs}
\emph{RxJs} je biblioteka koja sadrži generičku implementaciju šablona \emph{Observer}\footnote{\emph{Observer} - eng. Posmatrač} za \emph{JavaScript}.
Deo je većeg skupa alata otvorenog koda pod nazivom \emph{ReactiveX} koji služe reaktivnom programiranju.
Reaktivno programiranje podrazumeva programiranje vođeno događajima. Popularna implementacija šablona \emph{Redux} koja se koristi za \emph{Angular} aplikacije
pod nazivom \emph{NgRx} je implementirana upravo nad ovom bibliotekom. Okruženje \emph{Pure} koristi
biblioteku \emph{RxJs} iz istih razloga, ali u značajno pojednostavljenoj varijanti.
\subsection{Ostali alati i biblioteke}
Pored glavnih alata opisanih u ovom poglavlju, korišćeni su i alati otvorenog koda za manje i jednostavnije zadatke.
Neki od njih su:
\begin{enumerate}
  \item \emph{Jest} - Okruženje za testiranje \emph{JavaScript} koda.
  \item \emph{JsDOM} - Implementacija pretraživača i DOM-а u redukovanoj konzolnoj verziji zarad lakšeg automatskog testiranja.
  \item \texttt{object-hash} - Implementacija različitih heš algoritama za heširanje
  \emph{JavaScript} objekata, zarad brzog poređenja objekata po vrednosti.
  \item \texttt{rfdc} - Implementacija algoritma za \underline{duboko} kloniranje \emph{JavaScript} objekata. 
\end{enumerate}

\section{Povezivanje}
Kao što je već pomenuto u sekciji \ref{subsec:mesto-povezivanja}, \code{index.ts} je prvi fajl
koji biva učitan nakon fajla \code{index.html}. Jedina funkcija koju pozivamo u ovom fajlu (u do sada prikazanim primerima)
je funkcija za povezivanje aplikacije: \code{bootstrap()}.
Njena implementacija nalazi se u fajlu \code{src/bootstrap.ts} i može se videti u primeru \ref{file:src:bootstrap.ts}.
\begin{lstlisting}[style=jsStyle, caption={Fajl \code{ToDoApp.ts}},label=file:src:bootstrap.ts]
import { Component } from "./component";
import { Store } from "./store";

export function bootstrap<AppModel>(
    domRoot: HTMLElement,
    rootComponentFactory: (state: () => AppModel) => Component<AppModel>,
    store: Store<AppModel>,
): Component<AppModel> {

    const appRoot = rootComponentFactory(() => store.state);
    store.state$.subscribe(state => {
        while (domRoot.firstChild) {
            domRoot.removeChild(domRoot.lastChild);
        }
        domRoot.appendChild(appRoot.render());
    });

    return appRoot;
}
\end{lstlisting}
Funkcija \code{bootstrap()} je generička funkcija koja prihvata jedan argument tipa,
koji odgovara tipu korenog modela podataka, i tri standardna argumenta. Standardni argumenti su:
\begin{enumerate}
  \item Referenca na element DOM-a.
  \item Konstruktorska funkcija komponente.
  \item Referenca na objekat skladišta.
\end{enumerate}
Ovi argumenti su već opisani u sekciji \ref{subsec:mesto-povezivanja}, pa njihovo značenje nećemo ovde ponovo navoditi.

Ukoliko bliže analiziramo prikazani kod, primetićemo da funkcija \code{bootstrap()} ima 3 zaduženja.
\begin{enumerate}
  \item Instanciranje korene komponente pozivom konstruktorske funkcije (Linja 10).
  \item Osluškivanje promene stanja skladišta (Linija 11).
  \item Registracija anonimne funkcije za ponovno iscrtavanje elemenata DOM-a (Linije 11-16).
\end{enumerate}
Iako će pojedinačni detalji komponenti, fabrike komponenata, skladišta i obrade događaja biti objašnjeni u kasnijim poglavljima,
ovde ćemo navesti neke važnije aspekte ovih elemenata, kako bismo jasnije razumeli prikazani kod. 

Primetimo da konstruktorsku funkciju, koju \code{bootsrap()} funkcija prihvata kao drugi argument,
u samom kodu nazivamo \code{rootComponentFactory}. Razlog je u tome što prosleđena funkcija nije 
samo jednostavni konstruktor, već ima dodatnu funkcionalnost u domenu optimizacije.
U liniji 11 vidimo poziv metode \code{subscribe()} nad objektom \code{store.state\$}.
Ovo je metoda koja je definisana u okviru biblioteke \emph{RxJs} nad tipom \code{Observable<T>.} Više detalja o ovom
i drugim tipovima iz biblioteke \emph{RxJs} biće u odeljku \ref{sec:promena-stanja}.


\section{Funkcionalni Elementi}
Tip \code{FunctionalElement} predstavlja interfejs najopštijeg nivoa u hijerarhiji strukturnih
elemenata okruženja \emph{Pure}\footnote{Elementi za opis DOM-strukture},
koji sadrži minimalan skup metoda koje se podrazumevano mogu pozvati nad bilo kojim elementom.
U kodu je definisan \emph{TypeScript} interfejsom na putanji \code{core/functionalElement.ts}
(Primer \ref{file:core:functionalElement.ts}).
\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/functionalElement.ts}},label=file:core:functionalElement.ts]
export interface FunctionalElement {
  render: () => HTMLElement;
  domElement: HTMLElement;
  children?: FunctionalElement[];
  parentDomElement: HTMLElement;
}

\end{lstlisting}
Interfejs \code{FunctionalElement} deklariše sledeće metode i polja:
\begin{enumerate}
\item Metodu \code{render()} koja se poziva pri iscrtavanju DOM-elemenata.
\item Referencu na DOM-element koji napravljen pozivanjem metode \code{render()}.
\item Listu potomaka.
\item Referencu na "roditelja" DOM-elementa (\code{null} u slučaju korene komponente).
\end{enumerate}
  
  Metodu \code{render()} koja se poziva pri iscrtavanju DOM-elemenata.
Važno je napomenuti da \emph{TypeScript} interfejsi mogu definisati i polja, a ne samo metode\footnote{Pošto direktno pristupanje poljima instance nije redak slučaj u \emph{JavaScript}-u, inženjeri
\emph{TypeScript}-a su odlučili da zvanično tako nešto i podrže u svojoj sintaksi.}.
\subsection{Ugrađeni Funkcionalni Elementi}
Kako bismo izgradili nove komponente koristeći šablon Kompozicije (eng. \emph{Composition Pattern}),
moramo se osloniti na neke postojeće, to jest, element ugrađene u okruženje. Elementi koji su ugrađeni
u okruženje \emph{Pure} su elementi koji predstavljaju pandan postojećim HTML elementima (\code{div}, \code{h1}, \code{span}...).
U nastavku poglavlja prikazaćemo implementaciju funkcionalnog elementa \code{div} kao i dijagram klasa koji
opisuje hijerarhiju i odnose elementa \code{div} sa ostalim elementima. Implementacija ostalih funkcionalnih elemenata može se naći na repozitorijumu aplikacije [reftorepo],
\\
\\
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.8\textwidth]{slike/HTMLFunctionalElement_dijagram.drawio.png}
  \caption{Dijagram klasa za klasu \code{HTMLFunctionalElement}}
  \label{fig:dijagram-klasa-HTMLFunctionalElement}
\end{figure}

Na osnovu dijagrama (slika \ref{fig:dijagram-klasa-HTMLFunctionalElement}) vidimo da \code{DivElement} nasleđuje
klasu \code{HTMLFunctionalElement}.
\\
Ukoliko pogledamo kod \code{DivElement} klase (Primer \ref{file:html:blockElements:divElement.ts}) primetićemo da klasa \code{DivElement}
ne dodaje nikakvo ponašanje u odnosu na klasu \code{HTMLFunctionalElement}, osim što fiksira argument imena elementa (\code{\_tag}).

\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{html/block/elements/divElement.ts}},label=file:html:blockElements:divElement.ts]
import { FunctionalElement, HTMLFunctionalElement } from '/core';
export class DivElement extends HTMLFunctionalElement {
    constructor(protected attributes: {}, protected _children: FunctionalElement[]) {
        super(attributes, _children, 'div')
    }
}
\end{lstlisting}

Kao što se da zaključiti iz njenog naziva, \code{HTMLFunctionalElement} je klasa koja definiše ponašanje svih ugrađenih
elemenata HTML-a.
Pogledajmo sada detalje implementacije klase \code{HTMLFunctionalElement}.

\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/htmlFunctionalElement.ts}},label=file:core:HTMLFunctionalElement.ts]
import { EventListening } from "./eventListening";
import { EventListeningBehaviour } from "./eventListeningBehaviour";
import { FunctionalElement } from "./functionalElement";

export abstract class HTMLFunctionalElement implements FunctionalElement, EventListening {
  public domElement: HTMLElement;
  public parentDomElement: HTMLElement;
  private _eventListeningExecutor: EventListeningBehaviour = null;

  constructor(protected attributes: {}, protected _children: FunctionalElement[], protected _tag: string) {
    if (arguments.length === 2) {
      // in case attributes object is provided as a first argument
      this.attributes = arguments[0];
      this._children = arguments[1];
    }
    else if (arguments.length === 1) {
      // in case we are provided with only one argument - we asume it is the array of children or a single child
      this._children = arguments[0];
    }
    this._eventListeningExecutor = new EventListeningBehaviour(this);
  }

  public on(event: string, ...handlers: ((event: Event) => void)[]) {
    this._eventListeningExecutor.on(event, ...handlers);
    return this;
  }

  public get children(): (FunctionalElement)[] {
    return this._children;
  }

  public render(): HTMLElement {
    this.createDomElement();
    this.assignAttributes();
    this.attachEventHandlers();
    return this.domElement;
  }

  public forceReRender() {
    let domElementToReplace = this.domElement;
    this.parentDomElement.replaceChild(this.render(), domElementToReplace);
  }

  protected assignAttributes(): void {
    if (this.attributes) {
      Object.keys(this.attributes).forEach(attribute => {
        if (this.attributes[attribute]) {
          this.domElement.setAttribute(attribute, this.attributes[attribute]);
        }
      });
    }
  }

  protected createDomElement(): void {
    this.domElement = document.createElement(this._tag);
    if (!this.children || this.children.length === 0) {
      return;
    }
    this.children.forEach(child => {
      child.parentDomElement = this.domElement;
      this.domElement.appendChild(child.render());
    });
  }

  private attachEventHandlers() {
    this._eventListeningExecutor.attachEventHandlers();
  }
}

\end{lstlisting}
Metoda \code{render()} klase \code{HTMLFunctionalElement} interno poziva tri privatne metode:
\begin{enumerate}
  \item Metodu za pravljenje elementa DOM-a (\code{createDomElement()}).
  \item Metodu za dodeljivanje potencijalno prosleđenih atributa napravljenom DOM-elementu (\code{assignAttributes()}).
  \item Metodu za registraciju osluškivača događaja (\code{attachEventHandlers()}).  
\end{enumerate}
U privatnoj metodi \code{createDomElement()}, nakon samog poziva za kreiranje DOM-elemenata se proverava
da li je funkcionalnom elementu prosleđena lista potomaka. Ukoliko jeste, metoda iterira kroz tu listu i rekurzivno
za svako dete poziva metodu \code{render()} i na taj način se formira celo drvo DOM-elemenata (Primer \ref{file:core:HTMLFunctionalElement.ts}, Linije 54-63).

Privatna metoda \code{assignAttributes()} prolazi kroz listu atributa koje imaju vrednost
\emph{truthy}\footnote{Skup vrednosti u \emph{JavaScript}-u koje se konverzijom prevode na \emph{boolean} vrednost \emph{TRUE}}
i dodeljuje prosleđene atribute DOM-elementu.

Mehanizam registrovanja osluškivača događaja i samo upravljanje događajima biće obrađeno u sekciji (REFERENCA).


\section{Komponente}
Komponente u okruženju \emph{Pure} predstavljaju funkcionalne elemente koji se dinamički mogu menjati
u odnosu na promenu stanja skladišta. Sve komponente moraju da naslede apstraktnu klasu \code{Component<T>}.
Ova apstraktna klasa ima jednu apstraktnu metodu \code{template()} koja se mora definisati u potklasi.

Metoda \code{template()} mora da vrati tip koji implementira interfejs \code{FunctionalElement}.
To može biti druga komponenenata ili neki od ugrađenih funkcionalnih elemenata.

Pošto klasa \code{Component<T>} implementira interfejs \code{FunctionalElement}, mora da implementira i metodu \code{render()}.
Metoda \code{render()} najpre proverava da li je stanje promenjeno u odnosu na prethodno i ukoliko nije,
vraća DOM-element koji je napravljen u prethodnom pozivu. Ukoliko je stanje promenjeno, trenutno stanje se čuva 
(kako bi moglo da se uporedi sa budućim), a nad objektom koji vraća metoda \code{template()} se poziva metoda \code{render()},
a rezultat tog poziva se vraća kao izlazna vrednost metode \code{render()}.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=1\textwidth]{slike/Component_dijagram.drawio.png}
  \caption{Dijagram klasa za klasu \code{Component<Model>}}
  \label{fig:dijagram-klasa}
\end{figure}
\\
\\
\\
Pogledajmo sada implementaciju klase \code{Component<T>}.
\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/component.ts}},label=file:core:component.ts]
import { FunctionalElement } from "./functionalElement";
import { EventListeningBehaviour } from "./eventListeningBehaviour";
import { areEqual, cloneDeep } from "../utils";
import { EventListening } from "./eventListening";

export abstract class Component<ModelType>  implements FunctionalElement, EventListening {
    public domElement: HTMLElement | Text = null;
    public parentDomElement: HTMLElement = null;

    protected inputState: () => ModelType = () => null;

    private _eventListeningExecutor: EventListeningBehaviour = null;
    private previousState: ModelType = null;

    constructor(inputState: () => ModelType) {
        this._eventListeningExecutor = new EventListeningBehaviour(this);
        this.inputState = inputState;
    }

    abstract template(): FunctionalElement;

    get state() {
        return this.inputState();
    }

    get children() {
        return this.template().children
    }

    public render() {
        if (this.stateIsUnchanged() && this.domElement) {
            return this.domElement;
        }

        this.savePreviousState();
        this.domElement = this.template().render();
        this.attachEventHandlers();

        return this.domElement;
    }

    public on(event: keyof HTMLElementEventMap, ...handlers: ((event: Event) => void)[]) {
        this._eventListeningExecutor.on(event, ...handlers);
        return this;
    }

    private attachEventHandlers() {
        this._eventListeningExecutor.attachEventHandlers();
    }
    
    private stateIsUnchanged() {
        return areEqual(this.inputState(), this.previousState);
    }

    private savePreviousState() {
        this.previousState = cloneDeep(this.inputState());
    }
};

\end{lstlisting}

\section{Obrada događaja}
Obratimo pažnju na pojedine elemente na dijagramu klasa koji opisuje okruženje klase
\code{Component<Model>} i dijagramu klasa koji opisuje okruženje klase \code{HTMLFunctionalElement}.
Videćemo da pored osnovnog interfejsa svih elemenata okruženja \emph{Pure} \code{FunctionalElement}
obe klase implementiraju interfejs \code{EventListening} i sadrže instancu klase koja direktno implementira ovaj interfejs
\code{EventListeningBehaviour}. Razlog za ovo je potreba za razdvajanjem interfejsa (eng. \emph{Interface Segregation})
i lakšim razvojem koda kroz princip "Kompozicija ispred Nasleđivanja" (eng. \emph{Composition over Inheritance}).

Koriščenjem (pojednostavljenog) šablona \emph{Dekorator} razdvajamo implementaciju za osluškivanje i
reagovanje na korisničke događaje.

Pogledajmo detalje ovog interfejsa i konkretne implemntacije (ista implementacija interfejska se koristi i za \code{HTMLFunctionalElement} i za \code{Component<Model>}).
\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/eventListening.ts}},label=file:core:eventListening.ts]
export interface EventListening {
  on: (event: keyof HTMLElementEventMap, ...handlers: ((event: Event) => void)[]) => this,
}
\end{lstlisting}

\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/eventListeningBehaviour.ts}},label=file:core:eventListeningBehaviour.ts]
import { EventListening } from "./eventListening";
import { FunctionalElement } from "./functionalElement";

export class EventListeningBehaviour implements EventListening {
  private eventHandlers: { event: keyof HTMLElementEventMap; handlers: ((event: any) => any)[]; }[] = [];
  constructor(private decoratedElement: FunctionalElement) { }

  public on(event: keyof HTMLElementEventMap, ...handlers: ((event: Event) => void)[]) {
    this.eventHandlers.push({event, handlers});
    return this;
  };

  public attachEventHandlers(): void {
    if (this.eventHandlers) {
        this.eventHandlers.forEach(event => {
            event.handlers.forEach(handler => {
              this.decoratedElement.domElement.addEventListener(event.event, handler);
            });
        });
    }
  }
}
\end{lstlisting}
\section{Promena stanja}\label{sec:promena-stanja}
Pogledajmo sada kako možemo dinamički izmeniti izgled naše aplikacije pomoću promene stanja skladišta.
\begin{lstlisting}[style=jsStyle, escapeinside=\#\#, caption={Fajl \code{core/eventListeningBehaviour.ts}},label=file:core:eventListeningBehaviour.ts]
import { BehaviorSubject } from "rxjs";

export class Store<Model> {
    private _stateSubject: BehaviorSubject<Model>;

    constructor(defaultState: Model) {
        this._stateSubject = new BehaviorSubject(defaultState);
    }

    updateState(newState: Partial<Model>) {
        this._stateSubject.next({...this._stateSubject.getValue(), ...newState });
    }

    get state() {
        return this._stateSubject.getValue();
    }

    get state$() {
        return this._stateSubject.asObservable();
    }
}
\end{lstlisting}
Skladište u razvojnom okruženju \emph{Pure} se zasniva na \code{BehaviorSubject<T>} tipu
iz biblioteke \emph{RxJs}. \code{BehaviorSubject<T>} je objedinjuje posmatrača i subjekta posmatranja
u šablonu \emph{Observer}\footnote{\emph{Observer} - eng. Posmatrač}. Drugim rečima, nad \code{Subject} tipom
(natklasa tipa \code{BehaviorSubject} definsina u biblioteci \emph{RxJs}) je objekat nad kojim možete da registruje
funkciju za obradu događaja pri promeni stanja (metoda \code{.subscribe(...)}), ali i objkat nad kojim možete
pozvati metodu za promenu stanja (metoda \code{.next(...)}).

Ovaj mehanizam omogućava nam da imamo centralizovan sistem za skladištenje podataka.
Pogledajmo kod konkretne implementacije.

Videćemo da klasa ima tri javne metode:
\begin{enumerate}
  \item Metodu za dohvatanje objekta nad kojim vršimo subskripciju (\code{state\$})
  \item Metodu za vraćanje trenutnog stanja.
  \item Metodu za promenu stanja.
\end{enumerate}
\section{Memoizacija}
\chapter{Diskusija}
\chapter{Zaključak}

% % primer liste
% Можемо правити и набрајања:
% \begin{enumerate}
% \item Анализа 1
% \item Линеарна алгебра
% \item Аналитичка геометрија
% \item Основи програмирања
% \end{enumerate}



% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
% \begin{biografija}
% \textbf{Вук Стефановић Караџић} (\emph{Тршић, 26. октобар/6. новембар
%   1787. — Беч, 7. фебруар 1864.}) био је српски филолог, реформатор
% српског језика, сакупљач народних умотворина и писац првог речника
% српског језика.  Вук је најзначајнија личност српске књижевности прве
% половине XIX века. Стекао је и неколико почасних доктората.
% Учествовао је у Првом српском устанку као писар и чиновник у
% Неготинској крајини, а након слома устанка преселио се у Беч,
% 1813. године. Ту је упознао Јернеја Копитара, цензора словенских
% књига, на чији је подстицај кренуо у прикупљање српских народних
% песама, реформу ћирилице и борбу за увођење народног језика у српску
% књижевност. Вуковим реформама у српски језик је уведен фонетски
% правопис, а српски језик је потиснуо славеносрпски језик који је у то
% време био језик образованих људи. Тако се као најважније године Вукове
% реформе истичу 1818., 1836., 1839., 1847. и 1852.
% \end{biografija}
% ------------------------------------------------------------------------------

\end{document} 